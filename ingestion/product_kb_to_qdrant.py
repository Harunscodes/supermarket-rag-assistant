import json
import uuid
from pathlib import Path
from typing import List, Dict

from qdrant_client import QdrantClient
from qdrant_client.models import Distance, VectorParams, PointStruct
from fastembed import TextEmbedding


# ------------ CONFIG ------------
QDRANT_PATH = "db.qdrant"
INPUT = Path("data/product_faqs.jsonl")      # 100 records generated by your script
COLLECTION = "kb_product_faqs"
BATCH = 128
EMBED_MODEL = "BAAI/bge-small-en-v1.5"       # 384-dim


def stable_uuid_from_id(stable_id: str) -> uuid.UUID:
    """Map your stable short id to a deterministic UUID."""
    return uuid.uuid5(uuid.NAMESPACE_DNS, f"product:{stable_id}")


def read_jsonl(path: Path) -> List[Dict]:
    return [json.loads(l) for l in path.read_text(encoding="utf-8").splitlines() if l.strip()]


def ensure_collection(client: QdrantClient, name: str):
    try:
        client.get_collection(name)
        print(f"Collection exists: {name}")
    except Exception:
        print(f"Creating collection: {name}")
        client.create_collection(
            collection_name=name,
            vectors_config=VectorParams(size=384, distance=Distance.COSINE),
        )


def main():
    assert INPUT.exists(), f"Input file not found: {INPUT}"
    data = read_jsonl(INPUT)
    print(f"Loaded {len(data)} records from {INPUT}")

    client = QdrantClient(path=QDRANT_PATH)
    ensure_collection(client, COLLECTION)

    embedder = TextEmbedding(model_name=EMBED_MODEL)

    points: List[PointStruct] = []
    for rec in data:
        # Concatenate question + answer for richer signal
        text = f"Q: {rec['question'].strip()}\nA: {rec['answer'].strip()}"
        vec = list(embedder.embed([text]))[0]

        pid = stable_uuid_from_id(rec["id"])
        payload = {
            "id": rec["id"],
            "brand": rec.get("brand", "SupermarketCo"),
            "category": rec.get("category"),
            "question": rec["question"],
            "answer": rec["answer"],
            "domain": rec.get("domain", "product"),
            "source": "product_faqs.jsonl",
        }
        points.append(PointStruct(id=str(pid), vector=vec, payload=payload))

        if len(points) >= BATCH:
            client.upsert(collection_name=COLLECTION, points=points)
            print(f"Upserted {len(points)} points...")
            points = []

    if points:
        client.upsert(collection_name=COLLECTION, points=points)
        print(f"Upserted {len(points)} points...")

    # Quick count
    count = client.count(COLLECTION, exact=True).count
    print(f"Done. Total points in '{COLLECTION}': {count}")


if __name__ == "__main__":
    main()
